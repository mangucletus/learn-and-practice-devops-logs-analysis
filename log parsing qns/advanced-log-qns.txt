## **Advanced Python Questions**  

### **1. Parse Timestamps & Detect Timezone Anomalies**  
**Task:** Check if any logs have timestamps outside the expected UTC timezone (`+0000`).  
**Expected Output:**  
python
[
    {"ip": "185.195.59.88", "timestamp": "2025-06-03T10:08:47.318Z", "timezone": "+0000"},  # Valid
    {"ip": "192.168.1.1", "timestamp": "2025-06-03T10:08:47.318Z", "timezone": "+0500"}  # Anomaly
]

### **2. Track User Session Durations**  
**Task:** For each IP, calculate the time difference between first and last request.  
**Expected Output:**  
python
{
    "185.195.59.88": "00:05:23",  # 5 min 23 sec
    "192.168.1.1": "00:01:45"
}

### **3. Detect Bots/Scrapers by User-Agent**  
**Task:** Flag non-browser UAs (e.g., `curl`, `Python-urllib`, `Go-http-client`).  
**Expected Output:**  
python
{
    "Python-urllib/3.10": 45,
    "curl/7.68.0": 32,
    "Go-http-client/1.1": 12
}

### **4. Calculate P99 Latency per Endpoint**  
**Task:** Compute the 99th percentile response time (if `$request_time` was logged).  
**Expected Output:**  
python
{
    "/api/data": "1.2s",
    "/login": "0.8s"
}

### **5. Identify Traffic Spikes (Rolling 1-min Avg vs Current)**  
**Task:** Compare current requests/min to a 10-min rolling average; flag spikes >50%.  
**Expected Output:**  
python
{
    "2025-06-03T10:15": {"current": 300, "avg": 150, "deviation": "100%"},
    "2025-06-03T10:20": {"current": 450, "avg": 200, "deviation": "125%"}
}

### **6. Detect Retry Patterns After 5xx Errors**  
**Task:** Find IPs retrying the same path within 5 seconds after a 5xx error.  
**Expected Output:**  
python
{
    "185.195.59.88": {
        "path": "/api/data",
        "first_failure": "2025-06-03T10:08:47.318Z",
        "retry_time": "4.2s"
    }
}

### **7. Geolocate IPs & Map Error Rates by Country**  
**Task:** Use a mock GeoIP DB to count 4xx/5xx errors per country.  
**Expected Output:**  
python
{
    "US": {"4xx": 120, "5xx": 45},
    "DE": {"4xx": 85, "5xx": 12}
}

### **8. Extract Embedded JSON Payloads (If Any)**  
**Task:** If logs contain JSON (e.g., `{"user_id": "abc"}`), parse and count occurrences.  
**Expected Output:**  
python
{
    "user_id=abc": 200,
    "device=ios": 150
}

### **9. Detect Slow Queries (Top 1% by Response Size)**  
**Task:** Identify endpoints with response sizes in the top 1%.  
**Expected Output:**  
python
[
    {"path": "/download", "bytes_sent": 5000000},
    {"path": "/report", "bytes_sent": 3000000}
]

### **10. Correlate Errors with Deployments (Using a Deployment Log)**  
**Task:** Given a deployment timestamp log, check if error rates spiked within 5 mins post-deploy.  
**Expected Output:**  
python
{
    "Deploy#123": {
        "time": "2025-06-03T10:00:00Z",
        "errors_before": 5,
        "errors_after": 150,
        "increase": "2900%"
    }
}

---

## **Intermediate Bash Questions**  

### **11. Real-Time 5xx Error Alerting**  
**Task:** Write a script that monitors `access.log` and alerts if 5xx errors exceed 5% in 1 minute.  
**Expected Output:**  
bash
[ALERT] 5xx error rate: 6.2% (threshold: 5%) at 2025-06-03T10:15:00Z

### **12. Aggregate Bandwidth by IP (Top 5 Consumers)**  
**Task:** Sum bytes sent (`$10`) per IP and return the top 5.  
**Expected Output:**  
bash
185.195.59.88 5000000
192.168.1.1 3000000

---
